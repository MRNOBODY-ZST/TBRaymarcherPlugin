// Copyright 2021 Tomas Bartipan and Technical University of Munich.
// Licensed under MIT license - See License.txt for details.
// Special credits go to : Temaran (compute shader tutorial), TheHugeManatee (original concept, supervision) and Ryan Brucks
// (original raymarching code).

//
// This shader generates an Octree acceleration structure.
//

#include "/Engine/Private/Common.ush"
#include "OctreeCommon.usf"

// The Octree Volume texture we're creating in this shader.
RWTexture3D<float> OctreeVolume;

// The minimum and maximum values found in the volume.
float2 MinMaxValues;

// The Volume we're propagating light through.
Texture3D Volume;

int LeafNodeSize = 32;

[numthreads(8, 8, 8)]
void MainComputeShader(uint3 voxelLoc : SV_DispatchThreadID)
{
	// Position in Leaf space (index of the leaf in the octree that this shader will generate)
    int3 pos = int3(voxelLoc.x, voxelLoc.y, voxelLoc.z);

	int3 posOffset = pos * LeafNodeSize;

	for (int x = 0; x < LeafNodeSize; x++)
	{
		for (int y = 0; y < LeafNodeSize; y++)
		{
			for (int z = 0; z < LeafNodeSize; z++)
			{
				int3 localPos = int3(x, y, z);
				int3 actualPos = posOffset + localPos;
				// For now, just copy volume value.
				OctreeVolume[actualPos] = Volume.Load(int4(actualPos, 0), 0).r * MinMaxValues.y;
			}
		}
	}
}
