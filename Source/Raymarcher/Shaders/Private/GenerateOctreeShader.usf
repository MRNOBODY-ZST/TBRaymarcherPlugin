// Copyright 2021 Tomas Bartipan and Technical University of Munich.
// Licensed under MIT license - See License.txt for details.
// Special credits go to : Temaran (compute shader tutorial), TheHugeManatee (original concept, supervision) and Ryan Brucks
// (original raymarching code).

//
// This shader propagates adding (or removing) a light in a single slice of a volume texture.
// (Has to be invoked per-slice to propagate through whole volume).
//

#include "/Engine/Private/Common.ush"
#include "OctreeCommon.usf"

// The Octree Volume texture we're creating in this shader.
RWTexture3D<float> OctreeVolume;

// The minimum and maximum values found in the volume.
float2 MinMaxValues;

// The Volume we're propagating light through.
Texture3D Volume;


[numthreads(8, 8, 8)]
void MainComputeShader(uint3 voxelLoc : SV_DispatchThreadID)
{
	// Position in Leaf space (index of the leaf in the octree that this shader will generate)
    int3 pos = int3(voxelLoc.x, voxelLoc.y, voxelLoc.z);

    uint sizeX, sizeY, sizeZ;
    OctreeVolume.GetDimensions(sizeX, sizeY, sizeZ);
    uint3 uResolution = uint3(sizeX, sizeY, sizeZ);
    
    // If we're removing a light, multiply alpha by -1. (but read/write buffers stay positive)
    OctreeVolume[pos] = Volume.Load(int4(pos, 0), 0);
}
