// Copyright 2024 - Tomas Bartipan
// Licensed under MIT license - See License.txt for details.
// Special credits go to :
// Temaran (compute shader tutorial), TheHugeManatee (original concept) and Ryan Brucks(original raymarching code).

//
// This shader generates an Octree acceleration structure.
//

#include "/Engine/Private/Common.ush"
#include "OctreeCommon.usf"

// The Volume we're reading data from.
Texture3D Volume;

// The Octree Mip 0 texture we're populating in this shader.
RWTexture3D<float> OctreeVolumeMip0;

// The minimum and maximum values found in the volume.
float2 MinMaxValues;

int LeafNodeSize = 8;

[numthreads(1, 1, 1)]
void MainComputeShader(uint3 voxelLoc : SV_DispatchThreadID)
{
    // Position in Leaf space (index of the leaf in the octree that this shader will generate)
    int3 Pos = int3(voxelLoc.x, voxelLoc.y, voxelLoc.z);
    int3 ThreadOffset = Pos * LeafNodeSize;

    // Copy the data from the input volume to maximal resolution mip first.
    for (int x = 0; x < LeafNodeSize; x++)
    {
        for (int y = 0; y < LeafNodeSize; y++)
        {
            for (int z = 0; z < LeafNodeSize; z++)
            {
                int3 LocalPos = int3(x, y, z);
                int3 ActualPos = ThreadOffset + LocalPos;
                // For now, just copy volume value.
                OctreeVolumeMip0[ActualPos] = Volume.Load(int4(ActualPos, 0), 0).r * MinMaxValues.y;
            }
        }
    }
}
